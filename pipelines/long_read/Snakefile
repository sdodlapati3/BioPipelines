# Long-Read Sequencing SV Analysis Pipeline
# ==========================================
# Snakemake workflow for structural variant detection using ONT/PacBio data

configfile: "config.yaml"

import os

# Get variables from config
SAMPLES = config["samples"]
PLATFORM = config["platform"]
RAW_DIR = config["raw_dir"]
PROCESSED_DIR = config["processed_dir"]
RESULTS_DIR = config["results_dir"]
REFERENCE = config["reference"]["genome"]

# Create output directories
os.makedirs(PROCESSED_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)
os.makedirs(f"{RESULTS_DIR}/qc", exist_ok=True)
os.makedirs(f"{RESULTS_DIR}/sv_calls", exist_ok=True)
os.makedirs(f"{RESULTS_DIR}/phased", exist_ok=True)

# Target rule
rule all:
    input:
        # QC reports
        expand(f"{RESULTS_DIR}/qc/{{sample}}_nanoplot/NanoPlot-report.html", sample=SAMPLES),
        # Aligned BAMs
        expand(f"{PROCESSED_DIR}/{{sample}}.sorted.bam", sample=SAMPLES),
        expand(f"{PROCESSED_DIR}/{{sample}}.sorted.bam.bai", sample=SAMPLES),
        # SV calls
        expand(f"{RESULTS_DIR}/sv_calls/{{sample}}.sniffles2.vcf", sample=SAMPLES),
        expand(f"{RESULTS_DIR}/sv_calls/{{sample}}.cutesv.vcf", sample=SAMPLES),
        # Merged SV calls
        f"{RESULTS_DIR}/sv_calls/merged.vcf",
        # Phased variants (if whatshap enabled)
        expand(f"{RESULTS_DIR}/phased/{{sample}}.phased.vcf", sample=SAMPLES) if config["phasing"]["use_whatshap"] else []

# Rule 1: Raw read QC with NanoPlot
rule nanoplot_qc:
    container: "/home/sdodl001_odu_edu/BioPipelines/containers/images/long-read_1.0.0.sif"
    input:
        fastq = f"{RAW_DIR}/{{sample}}.fastq.gz"
    output:
        report = f"{RESULTS_DIR}/qc/{{sample}}_nanoplot/NanoPlot-report.html",
        stats = f"{RESULTS_DIR}/qc/{{sample}}_nanoplot/NanoStats.txt"
    params:
        outdir = f"{RESULTS_DIR}/qc/{{sample}}_nanoplot",
        threads = config["qc"]["nanoplot_threads"],
        min_length = config["qc"]["min_read_length"],
        max_length = config["qc"]["max_read_length"],
        min_qual = config["qc"]["min_quality"]
    threads: config["qc"]["nanoplot_threads"]
    shell:
        """
        NanoPlot --fastq {input.fastq} \
            --outdir {params.outdir} \
            --threads {params.threads} \
            --minlength {params.min_length} \
            --maxlength {params.max_length} \
            --minqual {params.min_qual} \
            --plots dot hex kde
        """

# Rule 2: Align reads with Minimap2
rule minimap2_align:
    input:
        fastq = f"{RAW_DIR}/{{sample}}.fastq.gz",
        ref = REFERENCE
    output:
        bam = temp(f"{PROCESSED_DIR}/{{sample}}.unsorted.bam")
    params:
        preset = config["alignment"]["minimap2_preset"],
        threads = config["alignment"]["threads"],
        extra = "-a -L --MD --eqx"  # -a: SAM output, -L: long cigars, --MD: MD tag, --eqx: =/X for match/mismatch
    threads: config["alignment"]["threads"]
    resources:
        mem_mb = lambda wildcards, attempt: int(config["resources"]["alignment_mem"].replace("G", "")) * 1024 * attempt
    shell:
        """
        minimap2 -t {params.threads} -x {params.preset} {params.extra} \
            {input.ref} {input.fastq} | \
        samtools view -@ {params.threads} -b -o {output.bam}
        """

# Rule 3: Sort and index BAM
rule sort_bam:
    container: "/home/sdodl001_odu_edu/BioPipelines/containers/images/long-read_1.0.0.sif"
    input:
        bam = f"{PROCESSED_DIR}/{{sample}}.unsorted.bam"
    output:
        sorted_bam = f"{PROCESSED_DIR}/{{sample}}.sorted.bam",
        bai = f"{PROCESSED_DIR}/{{sample}}.sorted.bam.bai"
    params:
        threads = config["alignment"]["threads"],
        remove_secondary = config["filtering"]["remove_secondary"],
        remove_supplementary = config["filtering"]["remove_supplementary"],
        min_mapq = config["alignment"]["min_mapq"]
    threads: config["alignment"]["threads"]
    shell:
        """
        # Filter alignments
        FILTER_FLAGS=""
        {params.remove_secondary} && FILTER_FLAGS="$FILTER_FLAGS -F 0x100"
        {params.remove_supplementary} && FILTER_FLAGS="$FILTER_FLAGS -F 0x800"
        
        samtools view -@ {params.threads} -b -q {params.min_mapq} $FILTER_FLAGS {input.bam} | \
        samtools sort -@ {params.threads} -o {output.sorted_bam}
        
        samtools index -@ {params.threads} {output.sorted_bam}
        """

# Rule 4: Call SVs with Sniffles2
rule sniffles2_call:
    input:
        bam = f"{PROCESSED_DIR}/{{sample}}.sorted.bam",
        bai = f"{PROCESSED_DIR}/{{sample}}.sorted.bam.bai"
    output:
        vcf = f"{RESULTS_DIR}/sv_calls/{{sample}}.sniffles2.vcf"
    params:
        min_support = config["sv_calling"]["min_support"],
        min_svlen = config["sv_calling"]["min_svlen"],
        threads = config["alignment"]["threads"]
    threads: config["alignment"]["threads"]
    resources:
        mem_mb = lambda wildcards, attempt: int(config["resources"]["sv_calling_mem"].replace("G", "")) * 1024 * attempt
    shell:
        """
        sniffles --input {input.bam} \
            --vcf {output.vcf} \
            --threads {params.threads} \
            --minsupport {params.min_support} \
            --minsvlen {params.min_svlen}
        """

# Rule 5: Call SVs with CuteSV (alternative caller)
rule cutesv_call:
    container: "/home/sdodl001_odu_edu/BioPipelines/containers/images/long-read_1.0.0.sif"
    input:
        bam = f"{PROCESSED_DIR}/{{sample}}.sorted.bam",
        bai = f"{PROCESSED_DIR}/{{sample}}.sorted.bam.bai",
        ref = REFERENCE
    output:
        vcf = f"{RESULTS_DIR}/sv_calls/{{sample}}.cutesv.vcf"
    params:
        workdir = f"{RESULTS_DIR}/sv_calls/{{sample}}_cutesv_work",
        min_size = config["sv_calling"]["cutesv_min_size"],
        threads = config["sv_calling"]["cutesv_threads"],
        max_cluster_bias = config["sv_calling"]["cutesv_max_cluster_bias"]
    threads: config["sv_calling"]["cutesv_threads"]
    shell:
        """
        mkdir -p {params.workdir}
        
        cuteSV {input.bam} {input.ref} {output.vcf} {params.workdir} \
            --threads {params.threads} \
            --min_size {params.min_size} \
            --max_cluster_bias_INS {params.max_cluster_bias} \
            --diff_ratio_merging_INS 0.3 \
            --max_cluster_bias_DEL {params.max_cluster_bias} \
            --diff_ratio_merging_DEL 0.5 \
            --genotype
        
        rm -rf {params.workdir}
        """

# Rule 6: Merge SV calls from multiple samples
rule survivor_merge:
    container: "/home/sdodl001_odu_edu/BioPipelines/containers/images/long-read_1.0.0.sif"
    input:
        sniffles_vcfs = expand(f"{RESULTS_DIR}/sv_calls/{{sample}}.sniffles2.vcf", sample=SAMPLES),
        cutesv_vcfs = expand(f"{RESULTS_DIR}/sv_calls/{{sample}}.cutesv.vcf", sample=SAMPLES)
    output:
        merged = f"{RESULTS_DIR}/sv_calls/merged.vcf",
        vcf_list = temp(f"{RESULTS_DIR}/sv_calls/vcf_list.txt")
    params:
        max_distance = 1000,  # Maximum distance to merge SVs
        min_support = 1,      # Minimum caller support
        sv_type = 1,          # Take SV type into account
        strand = 1,           # Take strand into account
        min_svlen = 50        # Minimum SV length
    shell:
        """
        # Create list of VCF files
        echo {input.sniffles_vcfs} {input.cutesv_vcfs} | tr ' ' '\n' > {output.vcf_list}
        
        # Merge with SURVIVOR
        SURVIVOR merge {output.vcf_list} {params.max_distance} {params.min_support} \
            {params.sv_type} {params.strand} 0 {params.min_svlen} {output.merged}
        """

# Rule 7: Phase variants with WhatsHap
rule whatshap_phase:
    container: "/home/sdodl001_odu_edu/BioPipelines/containers/images/long-read_1.0.0.sif"
    input:
        vcf = f"{RESULTS_DIR}/sv_calls/{{sample}}.sniffles2.vcf",
        bam = f"{PROCESSED_DIR}/{{sample}}.sorted.bam",
        bai = f"{PROCESSED_DIR}/{{sample}}.sorted.bam.bai",
        ref = REFERENCE
    output:
        phased_vcf = f"{RESULTS_DIR}/phased/{{sample}}.phased.vcf"
    params:
        min_qual = config["phasing"]["min_phase_qual"],
        chromosomes = " ".join([f"--chromosome {c}" for c in config["phasing"]["chromosome_list"]]) if config["phasing"]["chromosome_list"] else ""
    shell:
        """
        whatshap phase {params.chromosomes} \
            --reference {input.ref} \
            --output {output.phased_vcf} \
            {input.vcf} {input.bam}
        """

# Rule 8: Generate alignment statistics
rule alignment_stats:
    container: "/home/sdodl001_odu_edu/BioPipelines/containers/images/long-read_1.0.0.sif"
    input:
        bam = f"{PROCESSED_DIR}/{{sample}}.sorted.bam"
    output:
        stats = f"{RESULTS_DIR}/qc/{{sample}}.samtools_stats.txt",
        flagstat = f"{RESULTS_DIR}/qc/{{sample}}.samtools_flagstat.txt"
    shell:
        """
        samtools stats {input.bam} > {output.stats}
        samtools flagstat {input.bam} > {output.flagstat}
        """
